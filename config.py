#! /usr/bin/env python3

from collections import namedtuple, OrderedDict
import subprocess
from os import path
from pprint import pprint

PinAssignment = namedtuple(
    'PinAssignment',
    ['red', 'green', 'blue', 'button1', 'button2'])


def hex(n, bytes=2):
    code = '0%dX' % (2 * bytes)
    return '0x' + format(n, code)

def get_git_version():
    dirty = subprocess.call(
        ['git', 'diff', '--quiet', 'HEAD'],
        cwd=path.dirname(__file__))

    hash = subprocess.check_output(['git', 'log', '-1', '--format=%h'])
    hash = hash.strip().decode();

    if dirty:
        hash += '-dirty'

    return hash;

CONFIG = {
    'version': get_git_version(),
    'num windows': 6,
    'pin assignment': [
       PinAssignment(0, 1, 2, 3, 4),
       PinAssignment(5, 6, 7, 8, 9),
       PinAssignment(10, 11, 12, 24, 25),
       PinAssignment(26, 27, 28, 29, 30),
       PinAssignment(23, 22, 21, 20, 19),
       PinAssignment(18, 17, 16, 15, 14),
    ],
    'usb identifier': {
        'vendor': hex(0x16c0),
        'product': hex(0x0486),
        'usage page': hex(0xFFAB),
        'usage id': hex(0x0002),        # This encodes protocol version.
    },
    'magic number': hex(0xA2, 1),
    'icd commands': {
        'GET_VERSION': 1,
        'SET_LED': 2,
        'VERSION_STRING': 16 + 1,
        'BUTTON_PRESS': 16 + 2,
    }
}

def new_file():
    file = list()
    file.append('// @' + 'generated')
    file.append('// This file was generated by ' + __file__ +'.')
    return file

def build_configuration():
    conf = new_file()
    conf.append('#ifndef WINDOWSNATCH_CONFIG_H')
    conf.append('#define WINDOWSNATCH_CONFIG_H')

    usb = CONFIG['usb identifier']
    conf.append('#define USB_VENDOR_ID %s' % usb['vendor'])
    conf.append('#define USB_PRODUCT_ID %s' % usb['product'])
    conf.append('#define USB_HID_USAGE_PAGE %s' % usb['usage page'])
    conf.append('#define USB_HID_USAGE_ID %s' % usb['usage id'])

    conf.append('#define CODE_VERSION_STR "%s"' % CONFIG['version'])
    conf.append('#define CODE_VERSION_LEN %s' % len(CONFIG['version']))

    conf.append('#endif // WINDOWSNATCH_CONFIG_H')

    return conf

mask_counter = 0
def mask_value():
    global mask_counter
    v = '0b1' + mask_counter * '0'
    mask_counter += 1
    return v

def build_keydown_config():
    conf = new_file()
    conf.append('#ifndef KEYDOWN_CONFIG_H')
    conf.append('#define KEYDOWN_CONFIG_H')
    conf.append('#include <stdint.h>')

    names = new_file()
    names.append('#ifndef BUTTON_NAMES_H')
    names.append('#define BUTTON_NAMES_H')

    i = 1;
    names.append('typedef enum BUTTONS {')

    buttons = OrderedDict()
    for set in CONFIG['pin assignment']:
        buttons['BUTTON%d1' % i] = set.button1
        buttons['BUTTON%d2' % i] = set.button2
        i += 1

    init, select = list(), list()
    for button, pin in buttons.items():
        names.append('%s = %d,' % (button, pin))
        conf.append('#define %s_MASK %s' % (button, mask_value()))
        init.append('pinMode(%s, INPUT_PULLDOWN);' % button)
        select.append(
            'if (button == %s)\n  return __is_keydown(button, %s_MASK);' % (
                button, button)
        )

    names.append('} button_t;')
    names.append('#endif // BUTTON_NAMES_H')

    incl = new_file()
    incl.append('void init_buttons() {')
    incl.extend(init)
    incl.append('}')

    incl.append('int is_keydown(button_t button) {')
    incl.extend(select)
    incl.append('return 0;')
    incl.append('}')

    button_count = CONFIG['num windows'] * 2
    if button_count <= 8:
        conf.append('typedef uint_fast8_t button_mask_t;')
    elif button_count <= 16:
        conf.append('typedef uint_fast16_t button_mask_t;')
    elif button_count <= 32:
        conf.append('typedef uint_fast32_t button_mask_t;')
    else:
        raise Exception('No type is large enough')

    conf.append('#endif // KEYDOWN_CONFIG_H')

    return names, conf, incl

root = path.dirname(__file__)
def write_to(filename, content):
    with open(root + filename, 'w') as file:
        file.write('\n'.join(content))

def assert_pin_sanity():
    pins = set()
    for pinset in CONFIG['pin assignment']:
        for pin in pinset:
            assert pin not in pins, 'Pin defined twice: %s' % pin
            pins.add(pin)

if __name__ == '__main__':
    assert CONFIG['num windows'] == len(CONFIG['pin assignment'])
    assert_pin_sanity()

    config = build_configuration()
    write_to('/windowsnatch/configuration.h', config)
    write_to('/teensy/src/configuration.h', config)

    'icd.h'

    names, conf, incl = build_keydown_config()
    write_to('/teensy/src/button_names.h', names)
    write_to('/teensy/src/button_setup.h', conf)
    write_to('/teensy/src/button_setup.inc', incl)



'''
The ICD looks like this:
- All messages are 64 bytes long, because I think that's how HID works.
- Byte 0: the magic number.
- Byte 1: Command.
- Bytes 2-63: payload.

For command SET_LED, payload is:
- Byte 2: number of pairs.
- Pair: Byte 0 - index of LED (0-based)
-       Byte 1 - Color (0-7), RGB, one bit per color.

For command BUTTON_PRESS:
- Byte 2: number of pairs.
- Pair: Byte 0 - index of LED (0-based)
-       Byte 1 - Which button pressed (1 or 2).


VERSION_STRING:
- NULL-terminated ASCII string starting at byte 2.
'''
